---
title: "Package Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{getting-started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_knit$set(root.dir = rprojroot::find_package_root_file())
devtools::document()
```
# Getting started {#start}
To classify breeding behaviour from light-level geolocator data in R we need a couple of R packages as well as functions that allow to run our code. 

The package requires _devtools_ (install if necessary using the _install.packages()_ function). With _devtools_ on your system, you are able to download and built as well as install R packages directly from GitHub (e.g. _BreedingBehaviour_).

```{r eval = FALSE}
library(devtools)
install_github("bennett-stolze/NestNetR")
```

You should now be able to load the package. We recommend to check (every now and then), if there is a new version of _BreedingBehaviour_ available. And if that is the case, re-install the package using the same code you used for initial installation.

```{r, message=FALSE, warning=FALSE}
library(NestNetR)
``` 


# 1 - Loading data
## 1.1 - Raw data
The first step is to load your raw data into R. Different geolocator types (e.g. from different manufacturers or different series) provide raw data in different formats. And while there are functions available to read a whole range of formats, you may have to either write your own function, use simple read text utilities or get in touch with the package managers to write code that fits your format if it is not yet implemented.

The most frequently used geolocators provide files with the extension `.lux` (Migrate Technology Ltd), `.lig` (BAS, Biotrack) or `.glf` (Swiss Ornithological Institute). The functions `read_lux` allows you to automatically read these different type of files. In most cases the raw data is stored in a text file that can also be read in to R using the base function `read.table()`.

With the suggested data structure, we can then define metadata information on the individual, the species, the deployment location, and define the sub-folder for saving and extracting data files.

```{r}
ID <- "D173"
Species <- "GreatKnot" #AreInt
wd <- "data"
dir.raw <- file.path(wd, "RawData", Species)
```

By using the above metadata we can use the `paste0` command to include this information in reading and writing of files.
The columns of our data need to be in a specific format with Date being a `POSIXc` class and Light, Tmin & Tmax being `numeric` integers. Check if the structure of your data follows the required format with the function `str`. If not adjust Date format with `as.POSIXct(raw_light$Date, tz = "GMT")`. We will load both light and temperature data to check their structure.

```{r}
raw_light <- read_lux(file.path(wd, "RawData", Species, paste0(ID, ".lux")))
head(raw_light)
str(raw_light)
```

```{r}
raw_deg <- read_deg(file.path(wd, "RawData", Species, paste0(ID, ".deg")))
head(raw_deg)
str(raw_deg)
```

## 1.2 - Identify breeding period
Since the raw data covers the entire migration route, the dataset must be trimmed to the breeding period before processing. This can be done either by automatically detecting the period using a corresponding twilight file (.twl) or by manually specifying the range.

### 1.2.1 - Automatic detection
If a twilight file is available, the breeding period can be automatically detected using the `auto = T` setting in the `set_breeding_period` function. Twilight files (`.csv`) can be created by functions associated with the _GeoLight_ or _TwGeos_ packages. The twilight file needs to be put into the Rawdata folder.

*Automatic Approach*
```{r}
tm.breeding <- set_breeding_period(raw_light, raw_deg, ID, Species, wd, auto = TRUE)
tm.breeding
```

*Manual Approach*
```{r}
tm.breeding <- set_breeding_period(raw_light, raw_deg, ID, Species, wd, auto = FALSE, gr.Device = "x11")
tm.breeding
```


# 2 - Preprocessing
To create consistent input for analysing the breeding behaviour, light and temperature recordings need to be combined into uniform time series. The final data frame thus needs to contain four columns with the following names:

1. Date
2. Light
3. Tmin
4. Tmax

Light data provides the reference timeline with the coarsest resolution, while temperature data needs to be aligned to it. Missing temperature values are interpolated by filling values backward over their original sampling intervals so that they match the resolution of the light data. 

All input variables are then normalised to a range of 0â€“1 to ensure comparability. To minimise the influence of extreme outliers, realistic value ranges are defined by calculating the 2.5th and 97.5th percentiles of each variable (`Light`, `Tmin`, `Tmax`) across all preprocessed data.

```{r}
# Create a directory inside you 'data' folder for saving breeding data
dir.create(file.path(wd, "BreedingData", Species), recursive = TRUE, showWarnings = FALSE)

# link directory
dir.breeding <- file.path(wd, "BreedingData", Species)

breeding_data <- preprocessing(ID, raw_light, raw_deg, tm.breeding, dir.breeding)
```


# 3 - Model 
## 3.1 - Training data (optional)
```{r}
devtools::document()
# gather data from all available geolocator records of your species 
breeding_data_list <- create_breeding_data_list(dir.breeding)

# Create training data 
preclassified_data <- create_trainingdata(breeding_data_list,
                                          segment_days = 1,
                                          gr.Device = "x11")

# Partition preclassified data into training- (80%) and test-data (20%) 
classes <- sapply(preclassified_data, `[[`, "Class") # extract classes
partition <- caret::createDataPartition(classes, p = 0.8, list = FALSE, times = 1) # 20% of each class goes to test data
training_data <- preclassified_data[partition]
test_data <- preclassified_data[-partition]

```

## 3.2 - Setting up the Model (optional)
```{r}
costum_model <- NULL

```

# 4 - Application
When there is no need for any model training or setting up a new model, the pre-trained model can be directly applied to the preprocessed data. The function `classify_breeding_behaviour` takes the preprocessed data and the metadata information as input and returns a list with the classified breeding behaviour state for each time point and a summary. If you did set up manually a model, use `model = costum`. 
```{r}
classified_breeding <- classify_breeding_behaviour(breeding_data)
```



# Processing of mulitple files
```{r}
files <- list.files(file.path(wd, "RawData", Species), pattern = ".lux", full.names = TRUE)
IDs <- sub("\\.lux$", "", basename(files))

for (ID in IDs) {
  raw_light <- read_lux(file.path(wd, "RawData", Species, paste0(ID, ".lux")))
  raw_deg <- read_deg(file.path(wd, "RawData", Species, paste0(ID, ".deg")))
  
  tm.breeding <- set_breeding_period(raw_light, raw_deg, ID, Species, wd, auto = TRUE)
  
  breeding_data <- preprocessing(raw_light, raw_deg, tm.breeding)
}
```